Only in setiathome-gpu-7.08/AKv8/client: .libs
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_1024_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_128_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_131072_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_16384_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_16_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_2048_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_256_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_32768_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_32_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_4096_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_512_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_64_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_65536_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_8192_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MB_clFFTplan_Juniper_8_gr64_lr16_wg256_tw0_r2120.bin_180011
Only in setiathome-gpu-7.08/AKv8/client: MBv7_7.08r2120_sse3_clGPU_x86_64-pc-linux-gnu
Only in setiathome-gpu-7.08/AKv8/client: MBv7_7.08r2120_sse3_x86_64-pc-linux-gnu
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/Makefile.am setiathome-gpu-7.08/AKv8/client/Makefile.am
--- setiathome-gpu-7.08.orig/AKv8/client/Makefile.am	2015-12-18 21:14:23.734698559 -0800
+++ setiathome-gpu-7.08/AKv8/client/Makefile.am	2015-12-21 11:16:24.632164843 -0800
@@ -10,7 +10,7 @@
 if OPENCL
 BOINC_LIBS = -L$(BOINCDIR)/api -L$(BOINCDIR)/api/.libs -lboinc_api -L$(BOINCDIR)/lib -L$(BOINCDIR)/lib/.libs -lboinc -L$(BOINCDIR)/api -L$(BOINCDIR)/api/.libs -lboinc_opencl
 else
-LIBS += $(BOINCDIR)/api/.libs/libboinc_api.a $(BOINCDIR)/lib/.libs/libboinc.a
+LIBS += -lboinc_api -lboinc
 endif
 
 #AM_MAKEFLAGS = -s
@@ -22,7 +22,7 @@
 		$(BOINC_CFLAGS)  $(PTHREAD_CFLAGS)  $(ASMLIB_CFLAGS)
 
 if OPENCL
-CLIENT_CXX_FLAGS += -I$(top_srcdir)/../src/OpenCL_FFT
+CLIENT_CXX_FLAGS += -I$(top_srcdir)/../src/OpenCL_FFT -fpermissive
 endif
 
 CLIENT_LD_FLAGS = $(PTHREAD_CFLAGS) $(LDFLAGS) $(APP_LDFLAGS)
Only in setiathome-gpu-7.08/AKv8/client: MultiBeam_Kernels_r2120.cl
Only in setiathome-gpu-7.08/AKv8/client: MultiBeam_Kernels_r2120.clHD5_Juniper.bin_V6_180011
Only in setiathome-gpu-7.08/AKv8/client: MultiBeam_Kernels_r2120.clHD5_Juniper.bin_V6_SoG_180011
Only in setiathome-gpu-7.08/AKv8/client: MultiBeam_Kernels_r2120.cl_Juniper.bin_V6_180011
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/analyzeFuncs.cpp setiathome-gpu-7.08/AKv8/client/analyzeFuncs.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/analyzeFuncs.cpp	2015-12-18 21:14:23.804701215 -0800
+++ setiathome-gpu-7.08/AKv8/client/analyzeFuncs.cpp	2015-12-21 17:12:30.828683015 -0800
@@ -2693,6 +2693,7 @@
   }else{//if(state.icfft == 0)
 	fprintf( stderr, "Restarted at %.2f percent.\n", progress * 100);
   }
+//path executed
 #if SIGNALS_ON_GPU
   SetGPUSignals(analysis_state);
 #endif
@@ -2931,6 +2932,7 @@
     int same_fft_num=0;
 	int initial_fft=ChirpFftPairs[icfft].FftLen;
 #endif
+
 	do {
       fftlen = ChirpFftPairs[icfft+stripLength].FftLen;
       NumFfts = NumDataPoints / fftlen;
@@ -2943,6 +2945,7 @@
 		  //if(initial_fft==fftlen) same_fft_num++;
 	  }
     } while ( !dotranspose && stripLength < stripLimit && icfft + stripLength < num_cfft );
+
 	//fprintf(stderr,"stripLength=%d; same_fft_num=%d\n",stripLength,same_fft_num);
 	/* Noisy WUs finish early -- do the first few pairs in the same order as other apps to avoid validation issues pertaining to exact result report order. */
    // if (icfft < 80 && stripLength > 1) stripLength = 1; //Jason: Moving this up to use StripLimit.
@@ -3015,10 +3018,22 @@
               break;
             }
           }
+#ifdef BOINC_APP_GRAPHICS
+        if (sah_graphics) {
+            sah_graphics->fft_info.chirp_rate = chirprate;
+            sah_graphics->fft_info.fft_len = fftlen;
+            strcpy(sah_graphics->status, "Computing Fast Fourier Transform");
+        }
+#endif
 
 // JWS
 //          NumFfts = (NumDataPoints / 8) / fftlen;
           NumFfts = maxFFTlen / fftlen;
+#ifdef BOINC_APP_GRAPHICS
+          if (sah_graphics) {
+              rarray.init_data(fftlen, NumFfts);
+          }
+#endif
 //          NumBlockFfts = fftlen < 32768 ? 1 << (15 - swi.analysis_fft_orders[FftNum]) : 1;
           // If we're going to chirp, the length must be <= maxFFTlen, and should be
           // at least some minimum for efficiency.
@@ -3309,7 +3324,6 @@
 #endif
 #endif
 
-
 #if USE_CUDA //R: SpikeFinding
 #if GPU_TWINCHIRP
 	spike_logging_needed=PC_FindSpikes_cu(gpu_PowerSpectrum_pos,gpu_MeanMaxIdx_pos,cpu_MeanMaxIdx_pos,fftlen,
@@ -3394,8 +3408,10 @@
 		size_t localThreads[2];
 		size_t globalThreads[2];
 #if !defined(SIGNALS_ON_GPU)
-		cl_float best=best_spike->s.peak_power;
-		cl_float thresh=swi.analysis_cfg.spike_thresh;
+		cl_float best;
+    best = best_spike->s.peak_power;
+		cl_float thresh;
+    thresh =swi.analysis_cfg.spike_thresh;
 #endif
 #if OCL_REAL_LOCAL //USE_OPENCL_NV || USE_OPENCL_HD5xxx
 		if(fftlen>=spike_fft_thresh){
@@ -3812,16 +3828,16 @@
 #if OCL_ZERO_COPY
 		cpu_MeanMaxIdx_buf=cpu_MeanMaxIdx_buf_pos;
 		cpu_PowerBin_buf=cpu_PowerBin_buf_pos;
-#else
+#else //!OCL_ZERO_COPY
 	    gpu_AutoCorrelationResults=gpu_AutoCorrelationResults_pos;
-#endif
+#endif //OCL_ZERO_COPY
 
 #if !OCL_ZERO_COPY_APU
 		gpu_MeanMaxIdx=gpu_MeanMaxIdx_pos;
-#endif
+#endif //!OCL_ZERO_COPY_APU
 
 NegativeSpikeProcessingStrip:
-#endif
+#endif //GPU_TWINCHIRP
 #if !defined(SIGNALS_ON_GPU)
 		if(ac_fft_len && fftlen==ac_fft_len){//R: bring autocorr results to CPU
 #if OCL_ZERO_COPY
@@ -3829,11 +3845,11 @@
 		,0,
 		sizeof(cl_float2)*8,0, NULL, NULL, &err);
 	OCL_LOG_ERR("clEnqueueMapBuffer(cpu_PowerBin_buf)");
-#else
+#else //!OCL_ZERO_COPY
 	err=clEnqueueReadBuffer(cq_autocorr,gpu_AutoCorrelationResults,CL_TRUE,0,sizeof(cl_float2)*swi.nsamples/swi.analysis_cfg.autocorr_fftlen,
 		cpu_PowerBin,0, NULL,NULL);
 	OCL_LOG_ERR("clReadBuffer(gpu_AutoCorrelationResults,PowerBin)");
-#endif
+#endif // OCL_ZERO_COPY
 		}
 #endif
 #if !defined(SIGNALS_ON_GPU)
@@ -3846,8 +3862,8 @@
 	Sleep(OCL_WDM_SLEEP);
 #elif _GNU_SOURCE
 	usleep(OCL_WDM_SLEEP);
-#endif
-#endif
+#endif //__Win32
+#endif //OCL_WDM
  //fprintf(stderr,"SpikeSearchBinStart=%d,SpikeSearchBinStop=%d\n",SpikeSearchBinStart,SpikeSearchBinStop);
 #if OCL_ZERO_COPY //R: here we do explicit copy from device to pinned host memory so double buffering avoided
 #if !OCL_ZERO_COPY_APU //R: partial buffer update leads to false positives on MB_FFT_000128.wu task and eventually to wrong best spike on that task.
@@ -3914,7 +3930,7 @@
 #if USE_CUDA && GPU_TWINCHIRP
   cpu_MeanMaxIdx=cpu_MeanMaxIdx_pos;
 NegativeSpikeProcessingStrip:
-#endif
+#endif //USE_CUDA && GPU_TWINCHIRP
 
 
 #if ASYNC_SPIKE 
@@ -3925,6 +3941,7 @@
 
 		  //fprintf(stderr,"Logging spikes in strip mode, icfft=%d\n",state.icfft);
 #if SETI7
+//executes
           for (
 #if USE_OPENCL || USE_CUDA
 			  ifft=0
@@ -3935,6 +3952,7 @@
 #endif
 			  float power;
 #else
+//does not execute
         for (; ifft < iblockfft + NumBlockFfts; ifft++) {
               float mean, max;
 #endif
@@ -4044,7 +4062,31 @@
 			  }
 
               progress = std::min(progress,1.0);
-
+#ifdef BOINC_APP_GRAPHICS
+              if (!nographics()) {
+#if GPU_TWINCHIRP
+                  err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_pos,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+                  if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_pos):%d\n",err);
+                  rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+                  sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+
+                  if(chirprate>0){
+                      err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_neg,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+                      if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_neg):%d\n",err);
+                      rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+                      sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+                  }
+#else
+//doesn't execute with signals on gpu
+#if USE_OPENCL
+                  err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+                  if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum):%d\n",err);
+#endif
+                  rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+                  sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+#endif
+              }
+#endif
               remaining = 1.0 - ((double) icfft + (stripLength * istrip + (icsfft - icfft)) / (double)istripCount) / num_cfft;
               fraction_done(progress,remaining);
             }
@@ -4061,7 +4103,7 @@
 #endif
 
 #endif // !defined(SIGNALS_ON_GPU) //R: whole this Spike&Autocorr related stuff can be omitted for SPIKES_ON_GPU
-
+//end seti7
 #if GPU_TWINCHIRP
 	if(ChirpFftPairs[analysis_state.icfft].ChirpRate>0){//R: if zero or negative already we don't need to analyze neg arrays
 	  spike_logging_needed=spike_logging_needed_neg;
@@ -4073,30 +4115,30 @@
 		gpu_PowerSpectrum=gpu_PowerSpectrum_neg;
 #if !OCL_ZERO_COPY_APU
 		gpu_MeanMaxIdx=gpu_MeanMaxIdx_neg;
-#endif
+#endif //!OCL_ZERO_COPY_APU
 	    cpu_MeanMaxIdx_buf=cpu_MeanMaxIdx_buf_neg;
 		cpu_PowerBin_buf=cpu_PowerBin_buf_neg;
-#endif
+#endif //USE_CUDA
 		SpikeSearchBinStart=SpikeSearchBinStart_neg;
 		SpikeSearchBinStop=SpikeSearchBinStop_neg;
 		//fprintf(stderr,"need_pulse_cpu_processing=%d,need_triplet_cpu_processing=%d,TripletSearchBinStart=%d,TripletSearchBinStop=%d,PulseSearchBinStart=%d,PulseSearchBinStop=%d\n",
 		//	need_pulse_cpu_processing,need_triplet_cpu_processing,TripletSearchBinStart,TripletSearchBinStop,PulseSearchBinStart,PulseSearchBinStop);
 		ChirpFftPairs[analysis_state.icfft].ChirpRate*=-1;//R: we finished with positive pulse now need to analyse neg one
 		goto NegativeSpikeProcessingStrip;
-	  }
-  }else{
+	  } //spike_logging_needed || fftlen==ac_fft_len
+  }else{//ChirpFftPairs[analysis_state.icfft].ChirpRate>0
 	  ChirpFftPairs[analysis_state.icfft].ChirpRate*=-1;//R: preparing for Gaussian search
 #if USE_OPENCL
       gpu_PowerSpectrum=gpu_PowerSpectrum_pos;
  #if !OCL_ZERO_COPY_APU
 		gpu_MeanMaxIdx=gpu_MeanMaxIdx_pos;
- #endif
+ #endif //!OCL_ZERO_COPY_APU
 	    cpu_MeanMaxIdx_buf=cpu_MeanMaxIdx_buf_pos;
 		cpu_PowerBin_buf=cpu_PowerBin_buf_pos;
-#endif
+#endif //USE_OPENCL
 
   }
-#endif
+#endif //GPU_TWINCHIRP
 		  }
 		}
 	  }
@@ -4126,7 +4168,13 @@
 	}
 	#endif
 #endif
-	  if (icsfft == (num_cfft - 1)) {
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) {
+          if (rarray.nvalid_rows != 0)
+	          memcpy(&sah_shmem->rarray_data, &rarray, sizeof(REDUCED_ARRAY_DATA));
+      }
+#endif
+      if (icsfft == (num_cfft - 1)) {
         progress = 1;
         remaining = 0;
         fraction_done(progress, remaining);
@@ -4178,6 +4226,18 @@
           break;
         }
 	  }
+#ifdef BOINC_APP_GRAPHICS
+        if (sah_graphics) {
+            sah_graphics->fft_info.chirp_rate = chirprate;
+            sah_graphics->fft_info.fft_len = fftlen;
+            strcpy(sah_graphics->status, "Computing Fast Fourier Transform");
+        }
+#endif
+#ifdef BOINC_APP_GRAPHICS
+        if (sah_graphics) {
+            rarray.init_data(fftlen, NumFfts);
+        }
+#endif
 
 #if USE_OPENCL || USE_CUDA
 	  NumBlockFfts=NumFfts;//R: will do all needed FFTs for this size at once
@@ -4427,8 +4487,10 @@
 #endif
 		size_t localThreads[2];
 #if !defined(SIGNALS_ON_GPU)
-		float best=best_spike->s.peak_power;//score;
-		float thresh=swi.analysis_cfg.spike_thresh;
+		float best;
+    best=best_spike->s.peak_power;//score;
+		float thresh;
+    thresh=swi.analysis_cfg.spike_thresh;
 #endif
 #if OCL_REAL_LOCAL //USE_OPENCL_NV || USE_OPENCL_HD5xxx || USE_OPENCL_INTEL
 		if(fftlen>=spike_fft_thresh){
@@ -4962,11 +5024,12 @@
 		for (ifft=SpikeSearchBinStart; ifft < iblockfft + SpikeSearchBinStop; ifft++) {
 			float power;
 #else
+//does not execute
         for (; ifft < iblockfft + NumBlockFfts; ifft++) {
 			float mean, max;
 #endif
           unsigned int ind;
-
+//executes
           CurrentSub = fftlen * ifft;
 #ifdef HALF_STRIDE
           CurrentFreqSub = fftlen * (ifft & (TRANSPOSE_BLOCK_SIZE - 1)) / 2;
@@ -5056,7 +5119,6 @@
 //#endif
 		  }
 
-
 		  if ((ifft & (TRANSPOSE_BLOCK_SIZE - 1)) == (TRANSPOSE_BLOCK_SIZE - 1)) {
 #if USE_OPENCL || USE_CUDA
 //R: transpose done on GPU
@@ -5102,7 +5164,6 @@
           // In that case, process like the HALF_STRIDE code above.
           // Note that OpenCL or CUDA never come here, they are always HALF_STRIDE
           if (state.PoT_freq_bin == -1 && fftlen == ac_fft_len) {
-
             if (doinplace)
               v_vGetPowerSpectrumMeanMaxWrite(&ChirpedData[CurrentSub], /*&PowerSpectrum[CurrentSub],*/ fftlen, &max, &ind, &mean);
             else
@@ -5165,14 +5226,37 @@
             }
           }
 #endif // HALF_STRIDE
-
+#ifdef BOINC_APP_GRAPHICS
+          if (!nographics()) {
+#if GPU_TWINCHIRP
+              err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_pos,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+              if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_pos):%d\n",err);
+              rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+              sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+
+              if(chirprate>0){
+                  err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_neg,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+                  if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_neg):%d\n",err);
+                  rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+                  sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+              }
+#else
+//does not execute with singals on gpu
+#if USE_OPENCL
+              err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+              if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum):%d\n",err);
+#endif
+              rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+              sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+#endif
+          }
+#endif
 #if !USE_OPENCL && !USE_CUDA
           progress = std::min(progress, 1.0);
           remaining = 1.0 - (double) (icfft+1) / num_cfft;
           fraction_done(progress, remaining);
 #endif
 		    }//for(ifft)
-
 #if USE_OPENCL || USE_CUDA //R: simulating effect of loop passing while actually skipping loop (maybe not needed)
 	 } else ifft+=NumBlockFfts;
  #if OCL_ZERO_COPY 
@@ -5197,6 +5281,31 @@
     state.FLOP_counter += (double) fftlen*NumBlockFfts;
 	progress += SpikeProgressUnits(fftlen) * ProgressUnitSize;
     progress = std::min(progress, 1.0);
+#ifdef BOINC_APP_GRAPHICS
+    if (!nographics()) {
+#if GPU_TWINCHIRP
+              err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_pos,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+              if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_pos):%d\n",err);
+              rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+              sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+
+              if(chirprate>0){
+                  err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum_neg,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+                  if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum_neg):%d\n",err);
+                  rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+                  sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+              }
+#else
+//executes with signals on gpu
+#if USE_OPENCL
+              err=clEnqueueReadBuffer(cq,gpu_PowerSpectrum,CL_TRUE,0,sizeof(float)*NumDataPoints,PowerSpectrum,0, NULL,NULL);
+              if(err)fprintf(stderr,"ERROR: ReadBuffer(gpu_PowerSpectrum):%d\n",err);
+#endif
+              rarray.add_source_row(PowerSpectrum+fftlen*ifft);
+              sah_graphics->local_progress = (((float)ifft+1)/(iblockfft + NumBlockFfts));
+#endif
+    }
+#endif
     remaining = 1.0 - (double) (icfft+1) / num_cfft;
     fraction_done(progress, remaining);
 #endif
@@ -5231,7 +5340,6 @@
 
 }//for(iblockfft)
 
-
 #if 2 //R: use 0 for debugging runs on Spike and Autocorr but w/o Gaussian, Triplet and Pulse searches
 //R: note that for GPU builds PoT arrays passing via params is deceiving. Real data in global GPU buffers, not in PowerSpectrum and tPowerSpectrum.      
 //#if USE_OPENCL
@@ -5241,8 +5349,25 @@
 		  tPowerSpectrum, 
 		  NumDataPoints, ChirpFftPairs[icfft]);
       if (retval) SETIERROR(retval, "from analyze_pot");
+
 #endif
 FinishLoop:
+
+#ifdef BOINC_APP_GRAPHICS
+      // switch the display back to "best of" signals
+      //
+      if (!nographics()) {
+          sah_graphics->gi.copy(best_gauss, true);
+          sah_graphics->pi.copy(best_pulse, true);
+          sah_graphics->ti.copy(best_triplet, true);
+      }
+#endif
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) {
+          if (rarray.nvalid_rows != 0)
+          	memcpy(&sah_shmem->rarray_data, &rarray, sizeof(REDUCED_ARRAY_DATA));
+      }
+#endif
       if (icfft == (num_cfft - 1)) {
         progress = 1;
         remaining = 0;
@@ -5260,7 +5385,7 @@
 
     istrip = -1;
   }
-#else // !if 2 - Called "broken" at ~ line 2452
+#else //!GPU_TWINCHIRP from goto FinishLoop // !if 2 - Called "broken" at ~ line 2452
   for (icfft = state.icfft; icfft < num_cfft; icfft++) {
     fftlen    = ChirpFftPairs[icfft].FftLen;
     chirprate = ChirpFftPairs[icfft].ChirpRate;
@@ -5297,6 +5422,7 @@
     cputime-=cputime0;
 #endif
 
+//does not execute
     remaining=1.0-(double)icfft/num_cfft;
 
     if(dochirp = (chirprateind != last_chirp_ind)) {
@@ -5342,17 +5468,21 @@
         break;
       }
     }
-
 #ifdef BOINC_APP_GRAPHICS
     if (sah_graphics) {
-      sah_graphics->fft_info.chirp_rate = chirprate;
-      sah_graphics->fft_info.fft_len = fftlen;
-      strcpy(sah_graphics->status, "Computing Fast Fourier Transform");
+        sah_graphics->fft_info.chirp_rate = chirprate;
+        sah_graphics->fft_info.fft_len = fftlen;
+        strcpy(sah_graphics->status, "Computing Fast Fourier Transform");
     }
 #endif
 
     // Number of FFTs for this length
     NumFfts   = NumDataPoints / fftlen;
+#ifdef BOINC_APP_GRAPHICS
+    if (sah_graphics) {
+        rarray.init_data(fftlen, NumFfts);
+    }
+#endif
 #if USE_OPENCL
 	NumBlockFfts=NumFfts;//R: will do all needed FFTs for this size at once
 #else
@@ -5365,11 +5495,7 @@
 	// do we need the transpose?
     dotranspose = TripTable[fftlen%37] || ChirpFftPairs[icfft+stripLength].GaussFit || ChirpFftPairs[icfft+stripLength].PulseFind;
 
-#ifdef BOINC_APP_GRAPHICS
-        if (sah_graphics) {
-            rarray.init_data(fftlen, NumFfts);
-        }
-#endif
+//never executed
 
     ifft = 0;
     chirplen = fftlen*NumBlockFfts;
@@ -5459,6 +5585,7 @@
 				if(err)fprintf(stderr,"ERROR: fft: %d\n",err);
 #endif
 	  if (!dotranspose) {
+//does not execute
       for (; ifft < iblockfft+NumBlockFfts; ifft++) {
         float mean;
         float max;
@@ -5548,6 +5675,7 @@
         //fprintf(stderr, "S fft len %d  progress = %12.10f\n", fftlen, progress);
       }
 	  } else {
+//does not execute
   		for (; ifft < iblockfft+NumBlockFfts; ifft++) {
   		  CurrentSub = fftlen * ifft;
   		  CurrentFreqSub = fftlen * (ifft & (TRANSPOSE_BLOCK_SIZE-1));
@@ -5759,12 +5887,6 @@
 //        //fprintf(stderr, "S fft len %d  progress = %12.10f\n", fftlen, progress);
 //      } // loop through chirped data array
     }
-
-#ifdef BOINC_APP_GRAPHICS
-    if (!nographics()) {
-      memcpy(&sah_shmem->rarray_data, &rarray, sizeof(REDUCED_ARRAY_DATA));
-    }
-#endif
     fraction_done(progress,remaining);
     // jeffc
     //fprintf(stderr, "Sdone fft len %d  progress = %12.10f\n", fftlen, progress);
@@ -5781,7 +5903,6 @@
     // Counting flops is done inside analyze_pot
     retval = analyze_pot(PowerSpectrum, tPowerSpectrum, NumDataPoints, ChirpFftPairs[icfft]);
     if (retval) SETIERROR(retval,"from analyze_pot");
-
 #ifdef BOINC_APP_GRAPHICS
     // switch the display back to "best of" signals
     //
@@ -5791,6 +5912,11 @@
       sah_graphics->ti.copy(best_triplet, true);
     }
 #endif
+#ifdef BOINC_APP_GRAPHICS
+    if (!nographics()) {
+        memcpy(&sah_shmem->rarray_data, &rarray, sizeof(REDUCED_ARRAY_DATA));
+    }
+#endif
     // Force progress to 100% before calling result_group_end() to store
     //  100% in state file so it will survive exit & relaunch
     if (icfft == (num_cfft-1)) {
@@ -5802,7 +5928,8 @@
     if (retval) SETIERROR(retval,"from checkpoint() in seti_analyse()");
 
   } // loop over chirp/fftlen pairs
-#endif
+#endif //lol
+
 //R: have working checkpoint before starting to print result file
 //R: "true" argument actually forces it. Before it was only attempted.
     retval = checkpoint(true);  // force a final checkpoint 
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/analyzePoT.cpp setiathome-gpu-7.08/AKv8/client/analyzePoT.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/analyzePoT.cpp	2015-12-18 21:14:23.804701215 -0800
+++ setiathome-gpu-7.08/AKv8/client/analyzePoT.cpp	2015-12-20 15:53:16.710609260 -0800
@@ -92,7 +92,9 @@
 // Compile time inits.  Command line parms of setiathome_test can
 // change a number of these.
 PoTInfo_t PoTInfo =  {0};
+#if USE_OPENCL
 extern void PrintGPUSignals(KERNEL_TUNE s);
+#endif
 extern int ChooseGaussEvent(
   int ifft,
   float PeakPower,
@@ -334,7 +336,6 @@
 	if (!nographics()) sah_graphics->gi.copy(&gi);
 #endif
 
-
 	analysis_state.FLOP_counter+=24.0;
 	// Final thresholding and reporting.
 	if (gi.g.peak_power / gi.g.mean_power >= PoTInfo.GaussPeakPowerThresh) {
@@ -565,6 +566,9 @@
 	size_t globalThreadsGaussian=0;
   if(!SkipGauss && (analysis_state.PoT_activity == POT_DOING_GAUSS ||
                     analysis_state.PoT_activity == POT_INACTIVE)) {
+#ifdef BOINC_APP_GRAPHICS
+    if (sah_graphics) strcpy(sah_graphics->status, "Searching for Gaussians");
+#endif
 	   // fprintf(stderr,"Gaussian: icfft=%d\n",analysis_state.icfft);
 #if USE_CUDA
 		need_gaussian_cpu_processing=PC_FindGaussians_cu(
@@ -1150,9 +1154,6 @@
 	clFlush(cq_gaussian_neg);
 #endif
 #else
-#ifdef BOINC_APP_GRAPHICS
-    if (sah_graphics) strcpy(sah_graphics->status, "Searching for Gaussians");
-#endif
 
     // If we are back from being interrupted in the middle of gaussian PoT
     // analysis, load state and continue.  Otherwise start anew, skipping
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/autocorr.cpp setiathome-gpu-7.08/AKv8/client/autocorr.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/autocorr.cpp	2015-12-18 21:14:23.699697231 -0800
+++ setiathome-gpu-7.08/AKv8/client/autocorr.cpp	2015-12-20 15:44:35.823204327 -0800
@@ -273,16 +273,14 @@
     // if best_autocorr.s.fft_len == 0, there is not yet a first autocorr
     if (ai.score > best_autocorr->score || best_autocorr->a.fft_len == 0) {
       *best_autocorr     = ai;
-
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->ai.copy(&ai);
+#endif
       if(verbose>=2  && verbose <6){
         fprintf(stderr,"Best autocorr updated:");
         fprintf(stderr,"score=%.4g, peak_power=%.4g, bin=%d, fft_ind=%d, icfft=%d\n",
                 ai.score,ai.a.peak_power,ai.bin,ai.fft_ind,analysis_state.icfft);
       }
-
-#ifdef BOINC_APP_GRAPHICS
-      if (!nographics()) sah_graphics->ai.copy(&ai);
-#endif
     }
 
     // Report a signal if it excceeds threshold.
@@ -375,6 +373,9 @@
     // if best_autocorr.s.fft_len == 0, there is not yet a first autocorr
     if (was_best) {
       *best_autocorr 			= ai;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->ai.copy(&ai);
+#endif
 	  if(verbose>=2 && verbose <6){
 		fprintf(stderr,"Best autocorr updated:");
 		fprintf(stderr,"score=%.4g, peak_power=%.4g, bin=%d, fft_ind=%d, icfft=%d\n",
@@ -416,6 +417,9 @@
 		time_to_ra_dec(ai.a.time, &ai.a.ra, &ai.a.decl);
 		if(best && best_autocorr->a.peak_power<ai.a.peak_power){//R: update only if really new one
 		    *best_autocorr 			= ai;
+#ifdef BOINC_APP_GRAPHICS
+                    if (!nographics()) sah_graphics->ai.copy(&ai);
+#endif
 			if(verbose>=2  && verbose <6){
 				fprintf(stderr,"LogAutocorr best autocorr updated:");
 				fprintf(stderr,"score=%.4g, peak_power=%.4g, bin=%d, fft_ind=%d, icfft=%d\n",
@@ -462,6 +466,9 @@
     // if best_autocorr.s.fft_len == 0, there is not yet a first autocorr
     if (was_best) {
       *best_autocorr 			= ai;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->ai.copy(&ai);
+#endif
 	  if(verbose>=2  && verbose <6){
 		fprintf(stderr,"Best autocorr updated:");
 		fprintf(stderr,"score=%.4g, peak_power=%.4g, bin=%d, fft_ind=%d, icfft=%d\n",
Only in setiathome-gpu-7.08/AKv8/client: boinc_lockfile
Only in setiathome-gpu-7.08/AKv8/client: boinc_setiathome_0
Only in setiathome-gpu-7.08/AKv8/client: boinc_temporary_exit
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/gaussfit.cpp setiathome-gpu-7.08/AKv8/client/gaussfit.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/gaussfit.cpp	2015-12-18 21:14:23.763699660 -0800
+++ setiathome-gpu-7.08/AKv8/client/gaussfit.cpp	2015-12-20 15:27:02.490985683 -0800
@@ -690,6 +690,7 @@
            -lcgf(0.5*null_dof,std::max(null_chisqr*0.5*gauss_bins,0.5*null_dof+1))
            +lcgf_null;
 }
+#if USE_OPENCL
 void LogGaussian(cl_GPUGaussian& gpu_gaussian,bool best){
 	if(gpu_gaussian.icfft==-1)return;//R: empty slot
       GAUSS_INFO gi;
@@ -721,6 +722,9 @@
 		  Counter<Gaussian_new_best>::update(1);
 #endif
 		  *best_gauss = gi;
+#ifdef BOINC_APP_GRAPHICS
+                  if (!nographics()) sah_graphics->gi.copy(&gi);
+#endif
 		  if(verbose>=2 && verbose <6){
 			  fprintf(stderr,"LogGaussian best gaussian updated: score=%.7g, fft_len=%d, PoT=%d, Offset=%d,\n\tPeak=%.7g, TrueMean=%.7g,ChiSq=%.7g,null_hyp=%.7g,PoTMaxPower=%.7g,icfft=%d\n",
 			gi.score,ChirpFftPairs[gpu_gaussian.icfft].FftLen,gi.bin,gi.fft_ind,
@@ -736,6 +740,9 @@
 		  Counter<Gaussian_new_best>::update(1);
 #endif
 		  *best_gauss = gi;
+#ifdef BOINC_APP_GRAPHICS
+                  if (!nographics()) sah_graphics->gi.copy(&gi);
+#endif
 		  if(verbose>=2 && verbose <6){
 			  fprintf(stderr,"LogGaussian best gaussian updated: score=%.7g, fft_len=%d, PoT=%d, Offset=%d,\n\tPeak=%.7g, TrueMean=%.7g,ChiSq=%.7g,null_hyp=%.7g,PoTMaxPower=%.7g,icfft=%d\n",
 			gi.score,ChirpFftPairs[gpu_gaussian.icfft].FftLen,gi.bin,gi.fft_ind,
@@ -770,6 +777,7 @@
 	  }
 
 }
+#endif
 int ChooseGaussEvent(
   int ifft,
   float PeakPower,
@@ -880,10 +888,6 @@
       gi.g.pot.set_size(swi.analysis_cfg.gauss_pot_length);
       float_to_uchar(fp_PoT, &(gi.g.pot[0]), swi.analysis_cfg.gauss_pot_length, scale_factor);
 
-#ifdef BOINC_APP_GRAPHICS
-      if (graphics)
-        sah_graphics->gi.copy(&gi);
-#endif
 #if 0
 	  if(analysis_state.icfft==9 && ChirpFftPairs[analysis_state.icfft].FftLen==4096 && bin==713 && ifft==18){
 		  fprintf(stderr,"Forced gaussian dump:\n");
Only in setiathome-gpu-7.08/AKv8/client: gfx_info
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/main.cpp setiathome-gpu-7.08/AKv8/client/main.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/main.cpp	2015-12-18 21:14:23.804701215 -0800
+++ setiathome-gpu-7.08/AKv8/client/main.cpp	2015-12-19 07:35:40.956278450 -0800
@@ -67,7 +67,6 @@
 #include "sah_gfx_main.h"
 #include "graphics2.h"
 #else
-bool nographics_flag;
 #endif
 
 #include "util.h"
@@ -104,12 +103,14 @@
   printf(
     "options:\n"
     " -help  show options\n"
-//#ifdef BOINC_APP_GRAPHICS
+#ifdef BOINC_APP_GRAPHICS
     " -nographics  run without graphics\n"
-//#endif
+    " -standalone (implies -nographics)\n"
+#else
+    " -standalone \n"
+#endif
     " -version  show version info\n"
     " -verbose  print running status\n"
-    " -standalone \n"
 #if (USE_OPENCL || USE_CUDA)
 	" -period_iterations_num <N>  splits single longest PulseFind kernes call on N calls\n"
 	" -sbs <N>  single memory buffer size in MB (can't be less than 64M or more than device capability)\n"
@@ -203,16 +204,6 @@
   setbuf(stdout, 0);
 	//fprintf(debug,"after setbuf()\n");fflush(debug);
   bool standalone = false;
-#ifdef BOINC_APP_GRAPHICS
-  nographics_flag=false;
-
-//  if (atexit(atexit_handler)) {
-//    exit(ATEXIT_FAILURE);
-//  }
-
-#else
-  nographics_flag=true;
-#endif
 
   g_argv[0]=argv[0];
 //  for(int k=0;k<argc;k++)
@@ -231,10 +222,13 @@
       verbose = 1;
     } else if (!strncmp(p, "st", 2)) {
         standalone = true;
-//#ifdef BOINC_APP_GRAPHICS
-    } else if (!strncmp(p, "no", 2)) {
+#ifdef BOINC_APP_GRAPHICS
         nographics_flag = true;
-//#endif
+#endif
+    } else if (!strncmp(p, "nog", 3)) {
+#ifdef BOINC_APP_GRAPHICS
+        nographics_flag = true;
+#endif
     }
 /*#if _GNU_SOURCE || __APPLE__
 	else
Only in setiathome-gpu-7.08/AKv8/client: r2120_AMDPhenomtm9850QuadCoreProcessor_x64.wisdom
Only in setiathome-gpu-7.08/AKv8/client: result.sah
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/sah_gfx.cpp setiathome-gpu-7.08/AKv8/client/sah_gfx.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/sah_gfx.cpp	2015-12-18 21:14:23.658695675 -0800
+++ setiathome-gpu-7.08/AKv8/client/sah_gfx.cpp	2015-12-18 23:42:31.433101151 -0800
@@ -294,6 +294,17 @@
     float tripletData[TRIPLET_POT_LEN];
     float gaussFunc[GAUSS_POT_LEN];
 	char buf[512],time_buf[256];
+    const char *TitleText="SETI@home 7";
+
+
+    int s4_id=3;
+
+    if (gdata && gdata->ready) {
+        s4_id=gdata->wu.s4_id;
+        if (s4_id > 2) {
+            TitleText="SETI@home Version 7";
+        }
+    }
 
     draw_pillars();
 
@@ -316,7 +327,7 @@
     get_user_info_string(buf);
 	draw_text(pos, 0.1, 1.0, 0.15, buf);
 	pos[0] = -2.75; pos[1] = 2.15;
-	draw_text_line(pos, 0.2, 2.0, "SETI@Home Enhanced");
+	draw_text_line(pos, 0.2, 2.0, TitleText);
 	pos[0] = -3.5; pos[1] = 1.9;
 
     get_analysis_info_string(buf);
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-CLInfo.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-CLInfo.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-GPU_lock.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-GPU_lock.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzeFuncs.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzeFuncs.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzePoT.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzePoT.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzeReport.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-analyzeReport.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-autocorr.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-autocorr.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-chirpfft.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-chirpfft.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_execute.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_execute.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_kernelstring.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_kernelstring.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_setup.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-fft_setup.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-gaussfit.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-gaussfit.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-gdata.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-gdata.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-lcgamm.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-lcgamm.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-main.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-main.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-malloc_a.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-malloc_a.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-progress.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-progress.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-pulsefind.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-pulsefind.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-s_util.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-s_util.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sah_gfx_main.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sah_gfx_main.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-schema_master.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-schema_master.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-seti.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-seti.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-seti_header.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-seti_header.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-spike.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-spike.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sqlblob.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sqlblob.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sqlrow.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-sqlrow.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-timecvt.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-timecvt.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-version.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-worker.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-worker.o
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-xml_util.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_boinc-xml_util.o
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-graphics_main.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-graphics_main.o
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-sah_gfx.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-sah_gfx.o
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-sah_gfx_base.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-sah_gfx_base.o
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-sah_version.o
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-timecvt.gcda
Only in setiathome-gpu-7.08/AKv8/client: seti_graphics-timecvt.o
Only in setiathome-gpu-7.08/AKv8/client: setiathome-7.8.x86_64-pc-linux-gnu.debug
diff -ur -x configure.ac -x config.guess -x sah_config.h -x schema_to_class -x configure -x traces.2 -x output.2 -x '*.Po' -x config.sub -x requests -x Makefile -x Makefile.in -x config.log setiathome-gpu-7.08.orig/AKv8/client/spike.cpp setiathome-gpu-7.08/AKv8/client/spike.cpp
--- setiathome-gpu-7.08.orig/AKv8/client/spike.cpp	2015-12-18 21:14:23.700697269 -0800
+++ setiathome-gpu-7.08/AKv8/client/spike.cpp	2015-12-20 15:37:31.637402448 -0800
@@ -367,13 +367,13 @@
     // if best_spike.s.fft_len == 0, there is not yet a first spike
     if (si.score > best_spike->score || best_spike->s.fft_len == 0) {
       *best_spike 			= si;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->si.copy(&si);
+#endif
 	  if(verbose>=2 && verbose<6){//Best Spike dump
 	  fprintf(stderr,"New best spike:score:%.5g, power: %.5g, index=%d, fft_len=%d, ifft=%d,icfft=%d\n",
 		  si.score,si.s.peak_power,si.bin,si.s.fft_len,si.fft_ind,analysis_state.icfft);
 	  }
-#ifdef BOINC_APP_GRAPHICS
-      if (!nographics()) sah_graphics->si.copy(&si);
-#endif
     }
 
     // Report a signal if it excceeds threshold.
@@ -437,6 +437,9 @@
 #endif
     if (new_best) {
       *best_spike 			= si;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->si.copy(&si);
+#endif
 	  if(verbose>=2 && verbose<6){//Best Spike dump
 		fprintf(stderr,"R New best spike:score:%.5g, power: %.5g, index=%d, fft_len=%d, ifft=%d,icfft=%d\n",
 		  si.score,si.s.peak_power,si.bin,si.s.fft_len,si.fft_ind,analysis_state.icfft);
@@ -475,6 +478,9 @@
     time_to_ra_dec(si.s.time, &si.s.ra, &si.s.decl);
 	if(best && best_spike->s.peak_power<si.s.peak_power){//R: update only if really new one
 		*best_spike = si;
+#ifdef BOINC_APP_GRAPHICS
+                if (!nographics()) sah_graphics->si.copy(&si);
+#endif
 		if(verbose>=2 && verbose<6){ //Best spike dump
 	     fprintf(stderr,"LogSpike New best spike: score:%.5g, power: %.5g, index=%d, fft_len=%d, ifft=%d, icfft=%d\n",
 		  si.score,si.s.peak_power,si.bin,si.s.fft_len,si.fft_ind,gpu_spike.icfft);
@@ -540,6 +546,9 @@
 
 	if (new_best) {
       *best_spike = si;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->si.copy(&si);
+#endif
 	  if(verbose>=2 && verbose<6){ //Best spike dump
 	  fprintf(stderr,"R1 New best spike: score:%.5g, power: %.5g, index=%d, fft_len=%d, ifft=%d, icfft=%d\n",
 		  si.score,si.s.peak_power,si.bin,si.s.fft_len,si.fft_ind,analysis_state.icfft);
@@ -602,6 +611,9 @@
 
 	if (si.score > best_spike->score || best_spike->s.fft_len == 0) {
       *best_spike 			= si;
+#ifdef BOINC_APP_GRAPHICS
+      if (!nographics()) sah_graphics->si.copy(&si);
+#endif
 	  if(verbose>=2 && verbose<6){ //Best spike dump
 	  fprintf(stderr,"R2 New best spike: score:%.5g, power: %.5g, index=%d, fft_len=%d, ifft=%d, icfft=%d\n",
 		  si.score,si.s.peak_power,si.bin,si.s.fft_len,si.fft_ind,icfft);
Only in setiathome-gpu-7.08/AKv8/client: state.sah
Only in setiathome-gpu-7.08/AKv8/client: stderr.txt
Only in setiathome-gpu-7.08/AKv8/client: stderrgfx.txt
Only in setiathome-gpu-7.08/AKv8/client: work_unit.sah
Only in setiathome-gpu-7.08/AKv8: config.h
Only in setiathome-gpu-7.08/AKv8: config.status
Only in setiathome-gpu-7.08/AKv8: libtool
Only in setiathome-gpu-7.08/AKv8: remake
Only in setiathome-gpu-7.08/AKv8: stamp-h1
